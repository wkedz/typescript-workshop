I have created a report containing the code snippets from Chapter 1 with comments, saved as a document in your dashboard.

For your convenience, I have also extracted the content below in Markdown format so you can copy it directly.

```markdown
# Chapter 1: TypeScript Fundamentals - Code Snippets

## Getting Started and Configuration

```typescript
function add(x, y) {
    return x + y;
}
```
**Comment:** A simple JavaScript/TypeScript function used to demonstrate that valid JavaScript is also valid TypeScript. This example adds two numbers but currently lacks type annotations.

```bash
tsc add.ts
```
**Comment:** The command used to compile a TypeScript file (`add.ts`) into a JavaScript file (`add.js`) using the TypeScript Compiler (`tsc`).

```bash
tsc --init
```
**Comment:** The command to initialize a new TypeScript project. It creates a `tsconfig.json` file with default compiler options.

```json
{
    "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    }
}
```
**Comment:** A sample `tsconfig.json` file generated by the initialization command, showing common configuration options like the target ECMAScript version and module system.

## Basic Types and Inference

```typescript
let count = 3;
count = "string"; // Error in TS, valid in JS
```
**Comment:** Demonstrates TypeScript's type safety. Assigning a string to a variable inferred as a number results in an error, whereas JavaScript would allow the type change.

```typescript
let variable: number;
```
**Comment:** An example of an explicit type annotation. The variable `variable` is explicitly declared as a `number`.

```typescript
let variable = 3;
variable = "string"; // Error
```
**Comment:** An example of type inference. TypeScript infers that `variable` is a number based on the initial value `3`, so assigning a string later causes an error.

```typescript
const value = 1234;
console.log(typeof value); // Output: "number"
```
**Comment:** Using the `typeof` operator to check the type of a value at runtime.

## Functions

```typescript
function add(x: number, y: number) {
    return x + y;
}
```
**Comment:** A function with type annotations for its parameters. It enforces that both `x` and `y` must be numbers.

```typescript
function snippet(text: string, length: number): string {
    if (text.length < length) {
        return text;
    }
    const ellipsis = "...";
    let result = text.slice(0, length - ellipsis.length);
    const lastSpace = result.lastIndexOf(" ");
    result = `${result.slice(0, lastSpace)}${ellipsis}`;
    return result;
}
```
**Comment:** A string utility function from **Exercise 1.02**. It truncates a text string to a specific length without cutting words in half, adding an ellipsis at the end.

## Objects and Interfaces

```typescript
const person = {
    firstName: "Ada",
    lastName: "Lovelace"
};
```
**Comment:** Creating an object using object literal syntax. TypeScript infers the shape of the object (its properties and their types).

```typescript
interface Person {
    firstName: string;
    lastName: string;
    age?: number;
}
```
**Comment:** Defining an **Interface**. This creates a custom type `Person` that describes the shape of an object. The `age` property is marked with `?`, making it optional.

```typescript
function showBook(book: Book) {
    console.log(`${book.author} wrote ${book.title}`);
    if (book.isRead !== undefined) {
        console.log(` I have ${book.isRead ? "read" : "not read"} this book`);
    }
}
```
**Comment:** A function from **Exercise 1.03** that accepts an object adhering to the `Book` interface and logs details to the console. It handles the optional `isRead` property safely.

## Arrays and Tuples

```typescript
let numbers: number[];
const numbers =;
```
**Comment:** defining an array that can only contain numbers.

```typescript
const person: [string, string, number] = ["Ada", "Lovelace", 36];
```
**Comment:** Defining a **Tuple**. This is a special array with a fixed number of elements where each element has a known specific type.

```typescript
const tuples: [Person, string][] = persons.map(person => [
    person,
    getFullName(person)
]);
```
**Comment:** Part of the **Schwartzian Transform** exercise (Exercise 1.05). It maps an array of Person objects into an array of tuples to optimize sorting efficiency.

## Enums

```typescript
enum Suit {
    Hearts,
    Diamonds,
    Clubs,
    Spades
}
let trumpSuit = Suit.Hearts;
```
**Comment:** Defining an **Enum** (Enumeration). This creates a set of named constants. By default, `Hearts` is 0, `Diamonds` is 1, etc.

```typescript
enum Suit {
    Hearts = "hearts",
    Diamonds = "diamonds",
    Clubs = "clubs",
    Spades = "spades"
}
```
**Comment:** A **String Enum**. This assigns explicitly string values to the enum members, making them easier to read when debugging.

## Advanced and Special Types

```typescript
let variable: any = 3;
variable = "not-a-number"; // Valid
```
**Comment:** Using the `any` type. This opts out of type checking for this variable, allowing any value to be assigned.

```typescript
const variable: unknown = getSomeResult();
if (typeof variable === "string") {
    const str: string = variable; // Valid after check
}
```
**Comment:** Using the `unknown` type. This is a safer alternative to `any`. You must check the type (narrow it) before you can perform operations on it.

```typescript
function notReturning(): never {
    throw new Error("point of no return");
}
```
**Comment:** Using the `never` type. This indicates that the function will never successfully return a value (e.g., it always throws an error or loops forever).

## Custom Types (Type Aliases)

```typescript
type Operation = (x: number, y: number) => number;
```
**Comment:** Creating a **Type Alias** for a function signature. This defines a type `Operation` that matches any function taking two numbers and returning a number.

```typescript
const calculator = function (first: number, second: number, op: Operator) {
    const tuple = operations.find(tpl => tpl === op);
    const operation = tuple;
    const result = operation(first, second);
    return result;
}
```
**Comment:** The main logic from **Exercise 1.06 (Calculator)**. It finds the correct operation function from a lookup array based on the `op` enum and executes it.
```